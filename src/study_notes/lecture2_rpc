为何该课程从c++转向go
学生浪费大量时间在指针以及分配释放资源的bug上，C++上也没有很好的rpc的库。

Go的优点
并发友好 goroutines channels c
rpc封装得好
资源回收 
类型安

线程
线程是很有用的结构工具，go称之为goroutines,其他语言里叫做线程，需要较高的技巧

为何使用线程
1.可以实现并发，在分布式系统里面可以用于IO并发：当等待另一个服务器的回复时，（启一个线程处理当前请求）
2.多核 线程可以运行在多个核心

线程允许一个进程同事执行很多事情
线程之间可以共享内存
每一个线程可以有自己的线程状态：PC（组成原理中的概念，存放即将执行的指令的地址） 寄存器 栈

一个进程中的线程个数
1. 可能由结构决定，比如一个线程处理员一个客户端，一个线程用于后台任务
2. 可能由并发需求决定，一个活跃的线程占用一个核心，go运行时自动把goroutines调度到可用的核心。
3. 可能由IO并发的需求决定，数量由延时跟容量决定，当吞吐量不再增长时，就不创建新的线程，因为受到了IO的制约。
4. 线程开销不高 100 1000都没问题，百万级就不行了，原因线程创建和销毁还是有开销的。

线程当前挑战
线程之间如何共享数据
如果其他线程正在改变一个变量，那么当前线程应该读改之前还是改之后的值其实是有不同的结果的
使用互斥 或者不共享

线程之间的同步或者叫协调
如何等待当前其他线程先完成
1.使用channel，channel的读写是有阻塞的
2.waitgroup，启动一个线程，调用add+1，线程完成调用done-1，调用wait一直阻塞在主线程

并发的粒度
粗糙粒度 并发的情况较少
细粒度 并发多有很多竞争态和死锁

爬虫的挑战
IO并发管理
同时获取很多url的数据
增加每秒获取的url的数量
网络延迟相比网络带宽是一个更严重限制
只获取爬虫一次
避免网路资源浪费
节省远端服务器资源
需要记住已经爬过的urls

爬虫的解决方案
1. 序列爬虫
	搞一个 已经爬过的 map 避免重复
	整个map会递归地传递给页面 
	但是同时只能处理一个页面
2. 并发互斥爬虫
	每一个页面创建一个线程
	所有的thread共享 已经爬过的map

为何要使用互斥访问map
1. 两个页面读完map发现没有这个page 可能同一时间访问相同的page
2. 当一个页面读完以后 往map写的时候，如果有线程来读map，此时读到是不准的

一个channel 允许一个线程发送 另一个线程接受
一个线程发送给channel以后阻塞，不能再发，除非另一个线程来接受
接受也会一直阻塞 不能再接受 直到另一个线程发送

channel可以同时用来交流和同步



rpc也可以设计成不同的
1. 尽力去服务。 客户端发一次，等一段时间，若无reply，继续发，尝试几次失败后，报错。
坏的情况：
比如 Put("k",10); Put("k",20) 都成功了 但无法确定 在server端执行的顺序是什么。


什么时候这种尽力服务比较适用
只读服务  或者操作重复也不做什么的情况

更好的rpc模式 
2.最多一次服务 服务端检测重复的请求，返回之前的回复而不是重新跑
如何检测重复请求
客户端发送的时候加一个unique的id 同样的请求使用同样的xid
服务端检测xid是否已经收到过 如果是 回复之前的xid的reply
如果没有 设为已经收到过。

如何获取xid 大随机数 或者clientid+sequence
服务器必须最终丢弃老的rpc请求
1. 何时丢弃是安全的
每个客户端有一个xid 带sequence，收到后回复ack=seq+1,client下一个sequence为ack，服务器收到seq+1的请求后 丢弃之前小于seq的请求 
如果一个请求在处理 来了一个重复的请求 该请求设置为pending


至多一次可以避免重复请求，但是无法对丢失请求做处理
3. 所以最理想的是准确一次
如果server没有收到 client还是会去重试
如果server收到重复请求 对重复请求不做处理 返回之前的相同请求的回应










