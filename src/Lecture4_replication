容错
希望有一个服务是持续且无视故障的

完美的属性包括
可用性 及时发生故障依旧可用
强一致性 对于客户端来说看起来完全一样 (其实是数据一样)
对客户端透明
对于服务器软件透明（没懂）
高效

我们希望处理的失败
故障宕机
依赖故障（没懂
网络丢包
网络分区

并不处理
不正确执行（操作失误？）
配置错误
关联故障（没懂
恶意

行为
可用 如果一个server挂了
等待 比如网络完全失败
停机 多个server挂了


核心思想 复制
两个或更多的服务器
每个副本都保存了提供服务所需的一些状态 一个副本挂了 另一个继续

比如mr的master
worker已经可以容错了 但是master不行

如果可用 那么传输的状态

worker列表
哪一个job已经完成
那些workers 空闲
tcp连接状态
程序内存堆栈
cpu寄存器

大问题
什么样的状态复制
主机需要等备机吗（同步还是异步）
何时切换到备机
切换时发生异常怎么看
如何让备机快速工作

两个方法
1。 传输状态
主机执行服务 
主机把状态传给备机
2. 复制状态机
假设所有机子初始状态相同，那么主机做了什么操作，备机也执行一样的操作，所以最后两者的状态是一致的。这种方法只需要发送操作。

传输状态比较简单 但是传输的东西比较多

复制状态机效率高（因为操作数据比起状态数据量少） 但是实现复杂
lab2 3 4使用复制状态机

在那一层去定义复制状态机呢

用户代码层： 需要改服务端和客户端的代码 高效 发送的都是一些high level的
指令层：允许我们复制如何现有的服务器 w/o的一些改动 （不懂
但是需要更加细节的主从同步
还必须处理中断 DMA 一些奇怪的x86指令

下面说一个用于容错虚拟机的实用系统
非常有野心的系统
目标 容错
目标 客户端无法察觉到故障
目标 客户端 服务端的软件代码无需改变

高可用虚拟机

什么情况下会导致主从不一样
许多指令可以保证在主从上一致
只要内存和寄存器状态一样

然而也有不一样
来自于外部世界的输入 网络
从存储服务器读数据会不一样吗？
中断
循环计数？
竞态





















